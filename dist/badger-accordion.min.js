(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('uuid/v4'), require('transition-end')) :
	typeof define === 'function' && define.amd ? define(['uuid/v4', 'transition-end'], factory) :
	(global.BadgerAccordion = factory(global.uuidV4,global.onCSSTransitionEnd));
}(this, (function (uuid,transitionEnd) { 'use strict';

uuid = uuid && uuid.hasOwnProperty('default') ? uuid['default'] : uuid;
transitionEnd = transitionEnd && transitionEnd.hasOwnProperty('default') ? transitionEnd['default'] : transitionEnd;

/**
 *  ACCORDION
 *
 * A lightwight vanilla JS accordion with an exstensible API
 */

const uuidV4 = uuid;
/**
 * CONSTRUCTOR
 * initialises the object
 */
class BadgerAccordion {
    constructor(el, options) {
        const container = document.querySelector(el);

        // If el is not defined
        if (container == null) {
            return;
        }

        const defaults = {
            headerClass:        '.js-badger-accordion-header',
            panelClass:         '.js-badger-accordion-panel',
            panelInnerClass:    '.js-badger-accordion-panel-inner',
            hidenClass:         'is-hidden',
            initalisedClass:    'badger-accordion--initalised',
            headerDataAttr:     'data-badger-accordion-header-id',
            openMultiplePanels: false,
            openHeadersOnLoad:  [],
            headerOpenLabel:    'Open accordion panel',
            headerCloseLabel:   'Close accordion panel'
            // toggleEl:            // If you want to use a different element to trigger the accordion
        };

        // Options
        this.settings = Object.assign({}, defaults, options);

        // Setting getting elements
        this.container = container;
        this.headers = Array.from( this.container.querySelectorAll(this.settings.headerClass) );
        this.panels = Array.from( this.container.querySelectorAll(this.settings.panelClass) );
        this.toggleEl = this.settings.toggleEl !== undefined ? Array.from(this.container.querySelectorAll(this.settings.toggleEl)) : this.headers;

        // This is for managing state of the accordion. It by default sets
        // all accordion panels to be closed
        this.states = [].map.call(this.headers, header => {
            return { state: 'closed' };
        });

        this.ids = [].map.call(this.headers, header => {
            return { id: uuidV4() };
        });

        // This is to ensure that once an opne/close event has been fired
        // another cannot start until the first event has finished.
        // @TODO - get this working...
        this.toggling = false;

        // Initiating the accordion
        if( this.container ) {
            this.init();
        } else {
            console.log('Something is wrong with you markup...');
        }
    }


    /**
     *  INIT
     *
     *  Initalises the accordion
     */
    init() {
        // Sets up ID, aria attrs & data-attrs
        this._setupAttributes();

        // Setting up the inital view of the accordion
        this._initalState();

        // Setting the height of each panel
        this._setPanelHeight();

        // Inserting data-attribute onto each `header`
        this._insertDataAttrs();

        // Adding listeners to headers
        this._addListeners();

        //
        this._finishInitalisation();
    }


    /**
     *  INSERT DATA ATTRS
     *
     *  Updates state object for inital loading of the accordion
     */
    _initalState() {
        // Sets state object as per `this.settings.openHeadersOnLoad`
        const headersToOpen = this.settings.openHeadersOnLoad;

        if (headersToOpen.length) {
            this._openHeadersOnLoad(headersToOpen);
        }

        // Render DOM as per the updates `this.states` object
        this._renderDom();
    }


    /**
     *  INSERT DATA ATTRS
     *
     *  Adds `headerDataAttr` to all headers
     */
    _insertDataAttrs() {
        this.headers.forEach( (header, index) => {
            header.setAttribute(this.settings.headerDataAttr, index);
        });
    }


    /**
     *  FINISH INITALISATION
     *
     *  Adds in `initalisedClass` to accordion
     */
    _finishInitalisation() {
        this.container.classList.add(this.settings.initalisedClass);
    }


    /**
     *  ADD LISTENERS
     *
     *  Adds click event to each header
     */
    _addListeners() {
        // So we can reference the badger-accordion object inside out eventListener
        const _this = this;

        // Adding click event to accordion
        this.headers.forEach((header, index) => {
            header.addEventListener('click', function(event) {
                // Getting the target of the click
                // const clickedEl = event.target;

                _this.handleClick(header, index);
            });
        });
    }


    /**
     *  HANDLE CLICK
     *
     *  //TODO - Add comment
     *  @param {object} targetHeader - The header node you want to open
     */
    handleClick(targetHeader, headerIndex) {
        // Removing current `.` from `this.settings.headerClass` class so it can
        // be checked against the `targetHeader` classList
        const targetHeaderClass = this.settings.headerClass.substr(1);

        // Checking that the thing that was clicked on was the accordions header
        if (targetHeader.classList.contains(targetHeaderClass) && this.toggling === false) {
            this.toggling = true;

            // Updating states
            this.setState(headerIndex);


            // Render DOM as per the updates `this.states` object
            this._renderDom();
        }
    }


    /**
     *  SET STATES
     *
     *  Sets the state for all headers. The 'target header' will have its state toggeled
     *  @param {object} targetHeaderId - The header node you want to open
     */
    setState(targetHeaderId) {
        const states = this.getState();

        // TODO - improve this comment
        // If `this.settings.openMultiplePanels` is false we need to ensure only one panel
        // be can open at once. This will the state on all but the target header to 'closed'
        if (!this.settings.openMultiplePanels) {
            states.filter((state, index) => {
                if (index != targetHeaderId) {
                    state.state = 'closed';
                }
            });
        }

        // Toggles the state value of the target header. This was `array.find` but `find`
        // isnt supported in IE11
        states.filter((state, index) => {
            if (index == targetHeaderId) {
                const newState = this.toggleState(state.state);
                return (state.state = newState);
            }
        });
    }


    /**
     *  RENDER DOM
     *
     *  Renders the accordion in the DOM using the `this.states` object
     */
    _renderDom() {
        const states = this.getState();

        // Filter through all open headers and open them
        this.states.filter( (state, index) => {
            if(state.state === 'open') {
                let header = this.headers[index];

                this.open(index);
            }
        });

        // Filter through all closed headers and closes them
        this.states.filter( (state, index) => {
            if(state.state === 'closed') {
                const header = this.headers[index];

                this.close(index);
            }
        });
    }


    /**
     *  OPEN
     *
     *  Closes a specific panel
     *  @param {object} header - The header node you want to open
     */
    open(headerIndex) {
        this.togglePanel('open', headerIndex);
    }


    /**
     *  CLOSE
     *
     *  Closes a specific panel
     *  @param {object} header - The header node you want to close
     */
    close(headerIndex) {
        this.togglePanel('closed', headerIndex);
    }


    /**
     *  OPEN ALL
     *
     *  Opens all panels
     */
    openAll() {
        this.headers.forEach( header => {
            this.togglePanel('open', header);
        });
    }


    /**
     *  CLOSE ALL
     *
     *  Closes all panels
     */
    closeAll() {
        this.headers.forEach( header => {
            this.togglePanel('closed', header);
        });
    }


    /**
     *  GET STATE
     *
     *  Getting state of headers. By default gets state of all headers
     *  @param {string} animationAction - The animation you want to invoke
     *  @param {object} header          - The header node you want to animate
     */
    togglePanel(animationAction, headerIndex) {
        if(animationAction !== undefined && headerIndex !== undefined) {
            if(animationAction === 'closed') {
                // 1. Getting ID of panel that we want to close
                const header        = this.headers[headerIndex];
                const panelToClose  = this.panels[headerIndex];

                // 2. Closeing panel
                panelToClose.classList.add(this.settings.hidenClass);

                // 3. Set aria attrs
                header.setAttribute('aria-expanded', false);
                header.setAttribute('aria-label', this.settings.headerOpenLabel);

                // 4. Resetting toggling so a new event can be fired
                panelToClose.onCSSTransitionEnd(() => this.toggling = false );
            } else if(animationAction === 'open') {
                // 1. Getting ID of panel that we want to open
                const header      = this.headers[headerIndex];
                const panelToOpen = this.panels[headerIndex];

                // 2. Closeing panel
                panelToOpen.classList.remove(this.settings.hidenClass);

                // 3. Set aria attrs
                header.setAttribute('aria-expanded', true);
                header.setAttribute('aria-label', this.settings.headerCloseLabel);

                // 4. Resetting toggling so a new event can be fired
                panelToOpen.onCSSTransitionEnd(() => this.toggling = false );
            }
        }
    }


    // @TODO - is this needed anymore?
    // checkState(headerId) {
    //     let state = this.states[headerId].state;
    //
    //     if(state === 'closed') {
    //         return state;
    //     } else if(state === 'open') {
    //         return state;
    //     }
    // }


    /**
     *  GET STATE
     *
     *  Getting state of headers. By default gets state of all headers
     *  @param {array} headerIds - Id/'s of the headers you want to check
     */
    getState(headerIds = []) {
        if(headerIds.length && Array.isArray(headerIds)) {
            let states = headerIds.map( header => this.states[header] );

            return states;
        } else {
            return this.states;
        }
    }


    /**
     *  TOGGLE STATE
     *
     *  Toggling the state value
     *  @param {string} currentState - Current state value for a header
     */
    toggleState(currentState) {
        if(currentState !== undefined) {
            return (currentState === 'closed') ? 'open' : 'closed';
        }
    }



    /**
     *  HEADERS TO OPEN
     *
     *  Setting which headers should be open when accordion is initalised
     *  @param {array} headersToOpen - Array of ID's for the headers to be open
     */
    _openHeadersOnLoad(headersToOpen = []) {
        if (headersToOpen.length && Array.isArray(headersToOpen)) {
            let headers = headersToOpen.filter(header => header != undefined);

            headersToOpen.forEach(header => {
                return (this.states[header].state = 'open');
            });
        }
    }


    /**
     *  SET PANEL HEIGHT
     *
     *  Setting height for panels using pannels inner element
     */
    _setPanelHeight() {
        // [].forEach.(this.panels, (panel) => {
        this.panels.forEach(panel => {
            const panelInner = panel.querySelector(this.settings.panelInnerClass);

            let activeHeight = panelInner.offsetHeight;

            return panel.style.maxHeight = `${activeHeight}px`;
        });
    }


    _setupHeaders() {
        this.headers.forEach( (header, index) => {
            header.setAttribute('id', `badger-accordion-header-${this.ids[index].id}`);
            header.setAttribute('aria-controls', `badger-accordion-panel-${this.ids[index].id}`);
            header.setAttribute('aria-label', this.settings.headerOpenLabel);
        });
    }



    _setupPanels() {
        this.panels.forEach( (panel, index) => {
            panel.setAttribute('id', `badger-accordion-panel-${this.ids[index].id}`);
            panel.setAttribute('aria-labeledby', `badger-accordion-header-${this.ids[index].id}`);
        });
    }


    _setupAttributes() {
        // Adding ID & aria-controls
        this._setupHeaders();

        // Adding ID & aria-labeledby
        this._setupPanels();

        // Inserting data-attribute onto each `header`
        this._insertDataAttrs();
    }
}

return BadgerAccordion;

})));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFkZ2VyLWFjY29yZGlvbi5taW4uanMiLCJzb3VyY2VzIjpbIi4uL3NyYy9qcy9iYWRnZXItYWNjb3JkaW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIEFDQ09SRElPTlxuICpcbiAqIEEgbGlnaHR3aWdodCB2YW5pbGxhIEpTIGFjY29yZGlvbiB3aXRoIGFuIGV4c3RlbnNpYmxlIEFQSVxuICovXG5cbmltcG9ydCB1dWlkIGZyb20gJ3V1aWQvdjQnO1xuY29uc3QgdXVpZFY0ID0gdXVpZDtcbmltcG9ydCBvbkNTU1RyYW5zaXRpb25FbmQgZnJvbSAndHJhbnNpdGlvbi1lbmQnO1xuXG4vKipcbiAqIENPTlNUUlVDVE9SXG4gKiBpbml0aWFsaXNlcyB0aGUgb2JqZWN0XG4gKi9cbmNsYXNzIEJhZGdlckFjY29yZGlvbiB7XG4gICAgY29uc3RydWN0b3IoZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG5cbiAgICAgICAgLy8gSWYgZWwgaXMgbm90IGRlZmluZWRcbiAgICAgICAgaWYgKGNvbnRhaW5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICAgICAgICAgIGhlYWRlckNsYXNzOiAgICAgICAgJy5qcy1iYWRnZXItYWNjb3JkaW9uLWhlYWRlcicsXG4gICAgICAgICAgICBwYW5lbENsYXNzOiAgICAgICAgICcuanMtYmFkZ2VyLWFjY29yZGlvbi1wYW5lbCcsXG4gICAgICAgICAgICBwYW5lbElubmVyQ2xhc3M6ICAgICcuanMtYmFkZ2VyLWFjY29yZGlvbi1wYW5lbC1pbm5lcicsXG4gICAgICAgICAgICBoaWRlbkNsYXNzOiAgICAgICAgICdpcy1oaWRkZW4nLFxuICAgICAgICAgICAgaW5pdGFsaXNlZENsYXNzOiAgICAnYmFkZ2VyLWFjY29yZGlvbi0taW5pdGFsaXNlZCcsXG4gICAgICAgICAgICBoZWFkZXJEYXRhQXR0cjogICAgICdkYXRhLWJhZGdlci1hY2NvcmRpb24taGVhZGVyLWlkJyxcbiAgICAgICAgICAgIG9wZW5NdWx0aXBsZVBhbmVsczogZmFsc2UsXG4gICAgICAgICAgICBvcGVuSGVhZGVyc09uTG9hZDogIFtdLFxuICAgICAgICAgICAgaGVhZGVyT3BlbkxhYmVsOiAgICAnT3BlbiBhY2NvcmRpb24gcGFuZWwnLFxuICAgICAgICAgICAgaGVhZGVyQ2xvc2VMYWJlbDogICAnQ2xvc2UgYWNjb3JkaW9uIHBhbmVsJ1xuICAgICAgICAgICAgLy8gdG9nZ2xlRWw6ICAgICAgICAgICAgLy8gSWYgeW91IHdhbnQgdG8gdXNlIGEgZGlmZmVyZW50IGVsZW1lbnQgdG8gdHJpZ2dlciB0aGUgYWNjb3JkaW9uXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gT3B0aW9uc1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIFNldHRpbmcgZ2V0dGluZyBlbGVtZW50c1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gQXJyYXkuZnJvbSggdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbCh0aGlzLnNldHRpbmdzLmhlYWRlckNsYXNzKSApO1xuICAgICAgICB0aGlzLnBhbmVscyA9IEFycmF5LmZyb20oIHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5zZXR0aW5ncy5wYW5lbENsYXNzKSApO1xuICAgICAgICB0aGlzLnRvZ2dsZUVsID0gdGhpcy5zZXR0aW5ncy50b2dnbGVFbCAhPT0gdW5kZWZpbmVkID8gQXJyYXkuZnJvbSh0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKHRoaXMuc2V0dGluZ3MudG9nZ2xlRWwpKSA6IHRoaXMuaGVhZGVycztcblxuICAgICAgICAvLyBUaGlzIGlzIGZvciBtYW5hZ2luZyBzdGF0ZSBvZiB0aGUgYWNjb3JkaW9uLiBJdCBieSBkZWZhdWx0IHNldHNcbiAgICAgICAgLy8gYWxsIGFjY29yZGlvbiBwYW5lbHMgdG8gYmUgY2xvc2VkXG4gICAgICAgIHRoaXMuc3RhdGVzID0gW10ubWFwLmNhbGwodGhpcy5oZWFkZXJzLCBoZWFkZXIgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdGU6ICdjbG9zZWQnIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuaWRzID0gW10ubWFwLmNhbGwodGhpcy5oZWFkZXJzLCBoZWFkZXIgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgaWQ6IHV1aWRWNCgpIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRoaXMgaXMgdG8gZW5zdXJlIHRoYXQgb25jZSBhbiBvcG5lL2Nsb3NlIGV2ZW50IGhhcyBiZWVuIGZpcmVkXG4gICAgICAgIC8vIGFub3RoZXIgY2Fubm90IHN0YXJ0IHVudGlsIHRoZSBmaXJzdCBldmVudCBoYXMgZmluaXNoZWQuXG4gICAgICAgIC8vIEBUT0RPIC0gZ2V0IHRoaXMgd29ya2luZy4uLlxuICAgICAgICB0aGlzLnRvZ2dsaW5nID0gZmFsc2U7XG5cbiAgICAgICAgLy8gSW5pdGlhdGluZyB0aGUgYWNjb3JkaW9uXG4gICAgICAgIGlmKCB0aGlzLmNvbnRhaW5lciApIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1NvbWV0aGluZyBpcyB3cm9uZyB3aXRoIHlvdSBtYXJrdXAuLi4nKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogIElOSVRcbiAgICAgKlxuICAgICAqICBJbml0YWxpc2VzIHRoZSBhY2NvcmRpb25cbiAgICAgKi9cbiAgICBpbml0KCkge1xuICAgICAgICAvLyBTZXRzIHVwIElELCBhcmlhIGF0dHJzICYgZGF0YS1hdHRyc1xuICAgICAgICB0aGlzLl9zZXR1cEF0dHJpYnV0ZXMoKTtcblxuICAgICAgICAvLyBTZXR0aW5nIHVwIHRoZSBpbml0YWwgdmlldyBvZiB0aGUgYWNjb3JkaW9uXG4gICAgICAgIHRoaXMuX2luaXRhbFN0YXRlKCk7XG5cbiAgICAgICAgLy8gU2V0dGluZyB0aGUgaGVpZ2h0IG9mIGVhY2ggcGFuZWxcbiAgICAgICAgdGhpcy5fc2V0UGFuZWxIZWlnaHQoKTtcblxuICAgICAgICAvLyBJbnNlcnRpbmcgZGF0YS1hdHRyaWJ1dGUgb250byBlYWNoIGBoZWFkZXJgXG4gICAgICAgIHRoaXMuX2luc2VydERhdGFBdHRycygpO1xuXG4gICAgICAgIC8vIEFkZGluZyBsaXN0ZW5lcnMgdG8gaGVhZGVyc1xuICAgICAgICB0aGlzLl9hZGRMaXN0ZW5lcnMoKTtcblxuICAgICAgICAvL1xuICAgICAgICB0aGlzLl9maW5pc2hJbml0YWxpc2F0aW9uKCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiAgSU5TRVJUIERBVEEgQVRUUlNcbiAgICAgKlxuICAgICAqICBVcGRhdGVzIHN0YXRlIG9iamVjdCBmb3IgaW5pdGFsIGxvYWRpbmcgb2YgdGhlIGFjY29yZGlvblxuICAgICAqL1xuICAgIF9pbml0YWxTdGF0ZSgpIHtcbiAgICAgICAgLy8gU2V0cyBzdGF0ZSBvYmplY3QgYXMgcGVyIGB0aGlzLnNldHRpbmdzLm9wZW5IZWFkZXJzT25Mb2FkYFxuICAgICAgICBjb25zdCBoZWFkZXJzVG9PcGVuID0gdGhpcy5zZXR0aW5ncy5vcGVuSGVhZGVyc09uTG9hZDtcblxuICAgICAgICBpZiAoaGVhZGVyc1RvT3Blbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX29wZW5IZWFkZXJzT25Mb2FkKGhlYWRlcnNUb09wZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVuZGVyIERPTSBhcyBwZXIgdGhlIHVwZGF0ZXMgYHRoaXMuc3RhdGVzYCBvYmplY3RcbiAgICAgICAgdGhpcy5fcmVuZGVyRG9tKCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiAgSU5TRVJUIERBVEEgQVRUUlNcbiAgICAgKlxuICAgICAqICBBZGRzIGBoZWFkZXJEYXRhQXR0cmAgdG8gYWxsIGhlYWRlcnNcbiAgICAgKi9cbiAgICBfaW5zZXJ0RGF0YUF0dHJzKCkge1xuICAgICAgICB0aGlzLmhlYWRlcnMuZm9yRWFjaCggKGhlYWRlciwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGhlYWRlci5zZXRBdHRyaWJ1dGUodGhpcy5zZXR0aW5ncy5oZWFkZXJEYXRhQXR0ciwgaW5kZXgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqICBGSU5JU0ggSU5JVEFMSVNBVElPTlxuICAgICAqXG4gICAgICogIEFkZHMgaW4gYGluaXRhbGlzZWRDbGFzc2AgdG8gYWNjb3JkaW9uXG4gICAgICovXG4gICAgX2ZpbmlzaEluaXRhbGlzYXRpb24oKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQodGhpcy5zZXR0aW5ncy5pbml0YWxpc2VkQ2xhc3MpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogIEFERCBMSVNURU5FUlNcbiAgICAgKlxuICAgICAqICBBZGRzIGNsaWNrIGV2ZW50IHRvIGVhY2ggaGVhZGVyXG4gICAgICovXG4gICAgX2FkZExpc3RlbmVycygpIHtcbiAgICAgICAgLy8gU28gd2UgY2FuIHJlZmVyZW5jZSB0aGUgYmFkZ2VyLWFjY29yZGlvbiBvYmplY3QgaW5zaWRlIG91dCBldmVudExpc3RlbmVyXG4gICAgICAgIGNvbnN0IF90aGlzID0gdGhpcztcblxuICAgICAgICAvLyBBZGRpbmcgY2xpY2sgZXZlbnQgdG8gYWNjb3JkaW9uXG4gICAgICAgIHRoaXMuaGVhZGVycy5mb3JFYWNoKChoZWFkZXIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBoZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIC8vIEdldHRpbmcgdGhlIHRhcmdldCBvZiB0aGUgY2xpY2tcbiAgICAgICAgICAgICAgICAvLyBjb25zdCBjbGlja2VkRWwgPSBldmVudC50YXJnZXQ7XG5cbiAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVDbGljayhoZWFkZXIsIGluZGV4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqICBIQU5ETEUgQ0xJQ0tcbiAgICAgKlxuICAgICAqICAvL1RPRE8gLSBBZGQgY29tbWVudFxuICAgICAqICBAcGFyYW0ge29iamVjdH0gdGFyZ2V0SGVhZGVyIC0gVGhlIGhlYWRlciBub2RlIHlvdSB3YW50IHRvIG9wZW5cbiAgICAgKi9cbiAgICBoYW5kbGVDbGljayh0YXJnZXRIZWFkZXIsIGhlYWRlckluZGV4KSB7XG4gICAgICAgIC8vIFJlbW92aW5nIGN1cnJlbnQgYC5gIGZyb20gYHRoaXMuc2V0dGluZ3MuaGVhZGVyQ2xhc3NgIGNsYXNzIHNvIGl0IGNhblxuICAgICAgICAvLyBiZSBjaGVja2VkIGFnYWluc3QgdGhlIGB0YXJnZXRIZWFkZXJgIGNsYXNzTGlzdFxuICAgICAgICBjb25zdCB0YXJnZXRIZWFkZXJDbGFzcyA9IHRoaXMuc2V0dGluZ3MuaGVhZGVyQ2xhc3Muc3Vic3RyKDEpO1xuXG4gICAgICAgIC8vIENoZWNraW5nIHRoYXQgdGhlIHRoaW5nIHRoYXQgd2FzIGNsaWNrZWQgb24gd2FzIHRoZSBhY2NvcmRpb25zIGhlYWRlclxuICAgICAgICBpZiAodGFyZ2V0SGVhZGVyLmNsYXNzTGlzdC5jb250YWlucyh0YXJnZXRIZWFkZXJDbGFzcykgJiYgdGhpcy50b2dnbGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGluZyBzdGF0ZXNcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoaGVhZGVySW5kZXgpO1xuXG5cbiAgICAgICAgICAgIC8vIFJlbmRlciBET00gYXMgcGVyIHRoZSB1cGRhdGVzIGB0aGlzLnN0YXRlc2Agb2JqZWN0XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJEb20oKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogIFNFVCBTVEFURVNcbiAgICAgKlxuICAgICAqICBTZXRzIHRoZSBzdGF0ZSBmb3IgYWxsIGhlYWRlcnMuIFRoZSAndGFyZ2V0IGhlYWRlcicgd2lsbCBoYXZlIGl0cyBzdGF0ZSB0b2dnZWxlZFxuICAgICAqICBAcGFyYW0ge29iamVjdH0gdGFyZ2V0SGVhZGVySWQgLSBUaGUgaGVhZGVyIG5vZGUgeW91IHdhbnQgdG8gb3BlblxuICAgICAqL1xuICAgIHNldFN0YXRlKHRhcmdldEhlYWRlcklkKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlcyA9IHRoaXMuZ2V0U3RhdGUoKTtcblxuICAgICAgICAvLyBUT0RPIC0gaW1wcm92ZSB0aGlzIGNvbW1lbnRcbiAgICAgICAgLy8gSWYgYHRoaXMuc2V0dGluZ3Mub3Blbk11bHRpcGxlUGFuZWxzYCBpcyBmYWxzZSB3ZSBuZWVkIHRvIGVuc3VyZSBvbmx5IG9uZSBwYW5lbFxuICAgICAgICAvLyBiZSBjYW4gb3BlbiBhdCBvbmNlLiBUaGlzIHdpbGwgdGhlIHN0YXRlIG9uIGFsbCBidXQgdGhlIHRhcmdldCBoZWFkZXIgdG8gJ2Nsb3NlZCdcbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLm9wZW5NdWx0aXBsZVBhbmVscykge1xuICAgICAgICAgICAgc3RhdGVzLmZpbHRlcigoc3RhdGUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9IHRhcmdldEhlYWRlcklkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnN0YXRlID0gJ2Nsb3NlZCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUb2dnbGVzIHRoZSBzdGF0ZSB2YWx1ZSBvZiB0aGUgdGFyZ2V0IGhlYWRlci4gVGhpcyB3YXMgYGFycmF5LmZpbmRgIGJ1dCBgZmluZGBcbiAgICAgICAgLy8gaXNudCBzdXBwb3J0ZWQgaW4gSUUxMVxuICAgICAgICBzdGF0ZXMuZmlsdGVyKChzdGF0ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSB0YXJnZXRIZWFkZXJJZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1N0YXRlID0gdGhpcy50b2dnbGVTdGF0ZShzdGF0ZS5zdGF0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChzdGF0ZS5zdGF0ZSA9IG5ld1N0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiAgUkVOREVSIERPTVxuICAgICAqXG4gICAgICogIFJlbmRlcnMgdGhlIGFjY29yZGlvbiBpbiB0aGUgRE9NIHVzaW5nIHRoZSBgdGhpcy5zdGF0ZXNgIG9iamVjdFxuICAgICAqL1xuICAgIF9yZW5kZXJEb20oKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlcyA9IHRoaXMuZ2V0U3RhdGUoKTtcblxuICAgICAgICAvLyBGaWx0ZXIgdGhyb3VnaCBhbGwgb3BlbiBoZWFkZXJzIGFuZCBvcGVuIHRoZW1cbiAgICAgICAgdGhpcy5zdGF0ZXMuZmlsdGVyKCAoc3RhdGUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZihzdGF0ZS5zdGF0ZSA9PT0gJ29wZW4nKSB7XG4gICAgICAgICAgICAgICAgbGV0IGhlYWRlciA9IHRoaXMuaGVhZGVyc1tpbmRleF07XG5cbiAgICAgICAgICAgICAgICB0aGlzLm9wZW4oaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBGaWx0ZXIgdGhyb3VnaCBhbGwgY2xvc2VkIGhlYWRlcnMgYW5kIGNsb3NlcyB0aGVtXG4gICAgICAgIHRoaXMuc3RhdGVzLmZpbHRlciggKHN0YXRlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYoc3RhdGUuc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVyID0gdGhpcy5oZWFkZXJzW2luZGV4XTtcblxuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqICBPUEVOXG4gICAgICpcbiAgICAgKiAgQ2xvc2VzIGEgc3BlY2lmaWMgcGFuZWxcbiAgICAgKiAgQHBhcmFtIHtvYmplY3R9IGhlYWRlciAtIFRoZSBoZWFkZXIgbm9kZSB5b3Ugd2FudCB0byBvcGVuXG4gICAgICovXG4gICAgb3BlbihoZWFkZXJJbmRleCkge1xuICAgICAgICB0aGlzLnRvZ2dsZVBhbmVsKCdvcGVuJywgaGVhZGVySW5kZXgpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogIENMT1NFXG4gICAgICpcbiAgICAgKiAgQ2xvc2VzIGEgc3BlY2lmaWMgcGFuZWxcbiAgICAgKiAgQHBhcmFtIHtvYmplY3R9IGhlYWRlciAtIFRoZSBoZWFkZXIgbm9kZSB5b3Ugd2FudCB0byBjbG9zZVxuICAgICAqL1xuICAgIGNsb3NlKGhlYWRlckluZGV4KSB7XG4gICAgICAgIHRoaXMudG9nZ2xlUGFuZWwoJ2Nsb3NlZCcsIGhlYWRlckluZGV4KTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqICBPUEVOIEFMTFxuICAgICAqXG4gICAgICogIE9wZW5zIGFsbCBwYW5lbHNcbiAgICAgKi9cbiAgICBvcGVuQWxsKCkge1xuICAgICAgICB0aGlzLmhlYWRlcnMuZm9yRWFjaCggaGVhZGVyID0+IHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlUGFuZWwoJ29wZW4nLCBoZWFkZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqICBDTE9TRSBBTExcbiAgICAgKlxuICAgICAqICBDbG9zZXMgYWxsIHBhbmVsc1xuICAgICAqL1xuICAgIGNsb3NlQWxsKCkge1xuICAgICAgICB0aGlzLmhlYWRlcnMuZm9yRWFjaCggaGVhZGVyID0+IHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlUGFuZWwoJ2Nsb3NlZCcsIGhlYWRlcik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogIEdFVCBTVEFURVxuICAgICAqXG4gICAgICogIEdldHRpbmcgc3RhdGUgb2YgaGVhZGVycy4gQnkgZGVmYXVsdCBnZXRzIHN0YXRlIG9mIGFsbCBoZWFkZXJzXG4gICAgICogIEBwYXJhbSB7c3RyaW5nfSBhbmltYXRpb25BY3Rpb24gLSBUaGUgYW5pbWF0aW9uIHlvdSB3YW50IHRvIGludm9rZVxuICAgICAqICBAcGFyYW0ge29iamVjdH0gaGVhZGVyICAgICAgICAgIC0gVGhlIGhlYWRlciBub2RlIHlvdSB3YW50IHRvIGFuaW1hdGVcbiAgICAgKi9cbiAgICB0b2dnbGVQYW5lbChhbmltYXRpb25BY3Rpb24sIGhlYWRlckluZGV4KSB7XG4gICAgICAgIGlmKGFuaW1hdGlvbkFjdGlvbiAhPT0gdW5kZWZpbmVkICYmIGhlYWRlckluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmKGFuaW1hdGlvbkFjdGlvbiA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgICAgICAvLyAxLiBHZXR0aW5nIElEIG9mIHBhbmVsIHRoYXQgd2Ugd2FudCB0byBjbG9zZVxuICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlciAgICAgICAgPSB0aGlzLmhlYWRlcnNbaGVhZGVySW5kZXhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhbmVsVG9DbG9zZSAgPSB0aGlzLnBhbmVsc1toZWFkZXJJbmRleF07XG5cbiAgICAgICAgICAgICAgICAvLyAyLiBDbG9zZWluZyBwYW5lbFxuICAgICAgICAgICAgICAgIHBhbmVsVG9DbG9zZS5jbGFzc0xpc3QuYWRkKHRoaXMuc2V0dGluZ3MuaGlkZW5DbGFzcyk7XG5cbiAgICAgICAgICAgICAgICAvLyAzLiBTZXQgYXJpYSBhdHRyc1xuICAgICAgICAgICAgICAgIGhlYWRlci5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaGVhZGVyLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIHRoaXMuc2V0dGluZ3MuaGVhZGVyT3BlbkxhYmVsKTtcblxuICAgICAgICAgICAgICAgIC8vIDQuIFJlc2V0dGluZyB0b2dnbGluZyBzbyBhIG5ldyBldmVudCBjYW4gYmUgZmlyZWRcbiAgICAgICAgICAgICAgICBwYW5lbFRvQ2xvc2Uub25DU1NUcmFuc2l0aW9uRW5kKCgpID0+IHRoaXMudG9nZ2xpbmcgPSBmYWxzZSApO1xuICAgICAgICAgICAgfSBlbHNlIGlmKGFuaW1hdGlvbkFjdGlvbiA9PT0gJ29wZW4nKSB7XG4gICAgICAgICAgICAgICAgLy8gMS4gR2V0dGluZyBJRCBvZiBwYW5lbCB0aGF0IHdlIHdhbnQgdG8gb3BlblxuICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlciAgICAgID0gdGhpcy5oZWFkZXJzW2hlYWRlckluZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYW5lbFRvT3BlbiA9IHRoaXMucGFuZWxzW2hlYWRlckluZGV4XTtcblxuICAgICAgICAgICAgICAgIC8vIDIuIENsb3NlaW5nIHBhbmVsXG4gICAgICAgICAgICAgICAgcGFuZWxUb09wZW4uY2xhc3NMaXN0LnJlbW92ZSh0aGlzLnNldHRpbmdzLmhpZGVuQ2xhc3MpO1xuXG4gICAgICAgICAgICAgICAgLy8gMy4gU2V0IGFyaWEgYXR0cnNcbiAgICAgICAgICAgICAgICBoZWFkZXIuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaGVhZGVyLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIHRoaXMuc2V0dGluZ3MuaGVhZGVyQ2xvc2VMYWJlbCk7XG5cbiAgICAgICAgICAgICAgICAvLyA0LiBSZXNldHRpbmcgdG9nZ2xpbmcgc28gYSBuZXcgZXZlbnQgY2FuIGJlIGZpcmVkXG4gICAgICAgICAgICAgICAgcGFuZWxUb09wZW4ub25DU1NUcmFuc2l0aW9uRW5kKCgpID0+IHRoaXMudG9nZ2xpbmcgPSBmYWxzZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvLyBAVE9ETyAtIGlzIHRoaXMgbmVlZGVkIGFueW1vcmU/XG4gICAgLy8gY2hlY2tTdGF0ZShoZWFkZXJJZCkge1xuICAgIC8vICAgICBsZXQgc3RhdGUgPSB0aGlzLnN0YXRlc1toZWFkZXJJZF0uc3RhdGU7XG4gICAgLy9cbiAgICAvLyAgICAgaWYoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgLy8gICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgLy8gICAgIH0gZWxzZSBpZihzdGF0ZSA9PT0gJ29wZW4nKSB7XG4gICAgLy8gICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgLy8gICAgIH1cbiAgICAvLyB9XG5cblxuICAgIC8qKlxuICAgICAqICBHRVQgU1RBVEVcbiAgICAgKlxuICAgICAqICBHZXR0aW5nIHN0YXRlIG9mIGhlYWRlcnMuIEJ5IGRlZmF1bHQgZ2V0cyBzdGF0ZSBvZiBhbGwgaGVhZGVyc1xuICAgICAqICBAcGFyYW0ge2FycmF5fSBoZWFkZXJJZHMgLSBJZC8ncyBvZiB0aGUgaGVhZGVycyB5b3Ugd2FudCB0byBjaGVja1xuICAgICAqL1xuICAgIGdldFN0YXRlKGhlYWRlcklkcyA9IFtdKSB7XG4gICAgICAgIGlmKGhlYWRlcklkcy5sZW5ndGggJiYgQXJyYXkuaXNBcnJheShoZWFkZXJJZHMpKSB7XG4gICAgICAgICAgICBsZXQgc3RhdGVzID0gaGVhZGVySWRzLm1hcCggaGVhZGVyID0+IHRoaXMuc3RhdGVzW2hlYWRlcl0gKTtcblxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlcztcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogIFRPR0dMRSBTVEFURVxuICAgICAqXG4gICAgICogIFRvZ2dsaW5nIHRoZSBzdGF0ZSB2YWx1ZVxuICAgICAqICBAcGFyYW0ge3N0cmluZ30gY3VycmVudFN0YXRlIC0gQ3VycmVudCBzdGF0ZSB2YWx1ZSBmb3IgYSBoZWFkZXJcbiAgICAgKi9cbiAgICB0b2dnbGVTdGF0ZShjdXJyZW50U3RhdGUpIHtcbiAgICAgICAgaWYoY3VycmVudFN0YXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAoY3VycmVudFN0YXRlID09PSAnY2xvc2VkJykgPyAnb3BlbicgOiAnY2xvc2VkJztcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbiAgICAvKipcbiAgICAgKiAgSEVBREVSUyBUTyBPUEVOXG4gICAgICpcbiAgICAgKiAgU2V0dGluZyB3aGljaCBoZWFkZXJzIHNob3VsZCBiZSBvcGVuIHdoZW4gYWNjb3JkaW9uIGlzIGluaXRhbGlzZWRcbiAgICAgKiAgQHBhcmFtIHthcnJheX0gaGVhZGVyc1RvT3BlbiAtIEFycmF5IG9mIElEJ3MgZm9yIHRoZSBoZWFkZXJzIHRvIGJlIG9wZW5cbiAgICAgKi9cbiAgICBfb3BlbkhlYWRlcnNPbkxvYWQoaGVhZGVyc1RvT3BlbiA9IFtdKSB7XG4gICAgICAgIGlmIChoZWFkZXJzVG9PcGVuLmxlbmd0aCAmJiBBcnJheS5pc0FycmF5KGhlYWRlcnNUb09wZW4pKSB7XG4gICAgICAgICAgICBsZXQgaGVhZGVycyA9IGhlYWRlcnNUb09wZW4uZmlsdGVyKGhlYWRlciA9PiBoZWFkZXIgIT0gdW5kZWZpbmVkKTtcblxuICAgICAgICAgICAgaGVhZGVyc1RvT3Blbi5mb3JFYWNoKGhlYWRlciA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLnN0YXRlc1toZWFkZXJdLnN0YXRlID0gJ29wZW4nKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiAgU0VUIFBBTkVMIEhFSUdIVFxuICAgICAqXG4gICAgICogIFNldHRpbmcgaGVpZ2h0IGZvciBwYW5lbHMgdXNpbmcgcGFubmVscyBpbm5lciBlbGVtZW50XG4gICAgICovXG4gICAgX3NldFBhbmVsSGVpZ2h0KCkge1xuICAgICAgICAvLyBbXS5mb3JFYWNoLih0aGlzLnBhbmVscywgKHBhbmVsKSA9PiB7XG4gICAgICAgIHRoaXMucGFuZWxzLmZvckVhY2gocGFuZWwgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFuZWxJbm5lciA9IHBhbmVsLnF1ZXJ5U2VsZWN0b3IodGhpcy5zZXR0aW5ncy5wYW5lbElubmVyQ2xhc3MpO1xuXG4gICAgICAgICAgICBsZXQgYWN0aXZlSGVpZ2h0ID0gcGFuZWxJbm5lci5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgICAgIHJldHVybiBwYW5lbC5zdHlsZS5tYXhIZWlnaHQgPSBgJHthY3RpdmVIZWlnaHR9cHhgO1xuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIF9zZXR1cEhlYWRlcnMoKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5mb3JFYWNoKCAoaGVhZGVyLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaGVhZGVyLnNldEF0dHJpYnV0ZSgnaWQnLCBgYmFkZ2VyLWFjY29yZGlvbi1oZWFkZXItJHt0aGlzLmlkc1tpbmRleF0uaWR9YCk7XG4gICAgICAgICAgICBoZWFkZXIuc2V0QXR0cmlidXRlKCdhcmlhLWNvbnRyb2xzJywgYGJhZGdlci1hY2NvcmRpb24tcGFuZWwtJHt0aGlzLmlkc1tpbmRleF0uaWR9YCk7XG4gICAgICAgICAgICBoZWFkZXIuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgdGhpcy5zZXR0aW5ncy5oZWFkZXJPcGVuTGFiZWwpO1xuICAgICAgICB9KTtcbiAgICB9XG5cblxuXG4gICAgX3NldHVwUGFuZWxzKCkge1xuICAgICAgICB0aGlzLnBhbmVscy5mb3JFYWNoKCAocGFuZWwsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBwYW5lbC5zZXRBdHRyaWJ1dGUoJ2lkJywgYGJhZGdlci1hY2NvcmRpb24tcGFuZWwtJHt0aGlzLmlkc1tpbmRleF0uaWR9YCk7XG4gICAgICAgICAgICBwYW5lbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWxlZGJ5JywgYGJhZGdlci1hY2NvcmRpb24taGVhZGVyLSR7dGhpcy5pZHNbaW5kZXhdLmlkfWApO1xuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIF9zZXR1cEF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIC8vIEFkZGluZyBJRCAmIGFyaWEtY29udHJvbHNcbiAgICAgICAgdGhpcy5fc2V0dXBIZWFkZXJzKCk7XG5cbiAgICAgICAgLy8gQWRkaW5nIElEICYgYXJpYS1sYWJlbGVkYnlcbiAgICAgICAgdGhpcy5fc2V0dXBQYW5lbHMoKTtcblxuICAgICAgICAvLyBJbnNlcnRpbmcgZGF0YS1hdHRyaWJ1dGUgb250byBlYWNoIGBoZWFkZXJgXG4gICAgICAgIHRoaXMuX2luc2VydERhdGFBdHRycygpO1xuICAgIH1cbn1cblxuXG4vLyBFeHBvcnRcbmV4cG9ydCBkZWZhdWx0IEJhZGdlckFjY29yZGlvbjtcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7Ozs7O0FBTUEsQUFDQSxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUM7QUFDcEIsQUFFQTs7OztBQUlBLE1BQU0sZUFBZSxDQUFDO0lBQ2xCLFdBQVcsQ0FBQyxFQUFFLEVBQUUsT0FBTyxFQUFFO1FBQ3JCLE1BQU0sU0FBUyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDLENBQUM7OztRQUc3QyxJQUFJLFNBQVMsSUFBSSxJQUFJLEVBQUU7WUFDbkIsT0FBTztTQUNWOztRQUVELE1BQU0sUUFBUSxHQUFHO1lBQ2IsV0FBVyxTQUFTLDZCQUE2QjtZQUNqRCxVQUFVLFVBQVUsNEJBQTRCO1lBQ2hELGVBQWUsS0FBSyxrQ0FBa0M7WUFDdEQsVUFBVSxVQUFVLFdBQVc7WUFDL0IsZUFBZSxLQUFLLDhCQUE4QjtZQUNsRCxjQUFjLE1BQU0saUNBQWlDO1lBQ3JELGtCQUFrQixFQUFFLEtBQUs7WUFDekIsaUJBQWlCLEdBQUcsRUFBRTtZQUN0QixlQUFlLEtBQUssc0JBQXNCO1lBQzFDLGdCQUFnQixJQUFJLHVCQUF1Qjs7U0FFOUMsQ0FBQzs7O1FBR0YsSUFBSSxDQUFDLFFBQVEsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUM7OztRQUdyRCxJQUFJLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztRQUMzQixJQUFJLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUM7UUFDeEYsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDO1FBQ3RGLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLEtBQUssU0FBUyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQzs7OztRQUkxSSxJQUFJLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsTUFBTSxJQUFJO1lBQzlDLE9BQU8sRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLENBQUM7U0FDOUIsQ0FBQyxDQUFDOztRQUVILElBQUksQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxNQUFNLElBQUk7WUFDM0MsT0FBTyxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsRUFBRSxDQUFDO1NBQzNCLENBQUMsQ0FBQzs7Ozs7UUFLSCxJQUFJLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQzs7O1FBR3RCLElBQUksSUFBSSxDQUFDLFNBQVMsR0FBRztZQUNqQixJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7U0FDZixNQUFNO1lBQ0gsT0FBTyxDQUFDLEdBQUcsQ0FBQyx1Q0FBdUMsQ0FBQyxDQUFDO1NBQ3hEO0tBQ0o7Ozs7Ozs7O0lBUUQsSUFBSSxHQUFHOztRQUVILElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDOzs7UUFHeEIsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDOzs7UUFHcEIsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDOzs7UUFHdkIsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7OztRQUd4QixJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7OztRQUdyQixJQUFJLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztLQUMvQjs7Ozs7Ozs7SUFRRCxZQUFZLEdBQUc7O1FBRVgsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQzs7UUFFdEQsSUFBSSxhQUFhLENBQUMsTUFBTSxFQUFFO1lBQ3RCLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxhQUFhLENBQUMsQ0FBQztTQUMxQzs7O1FBR0QsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO0tBQ3JCOzs7Ozs7OztJQVFELGdCQUFnQixHQUFHO1FBQ2YsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxNQUFNLEVBQUUsS0FBSyxLQUFLO1lBQ3JDLE1BQU0sQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxjQUFjLEVBQUUsS0FBSyxDQUFDLENBQUM7U0FDNUQsQ0FBQyxDQUFDO0tBQ047Ozs7Ozs7O0lBUUQsb0JBQW9CLEdBQUc7UUFDbkIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsZUFBZSxDQUFDLENBQUM7S0FDL0Q7Ozs7Ozs7O0lBUUQsYUFBYSxHQUFHOztRQUVaLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQzs7O1FBR25CLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxFQUFFLEtBQUssS0FBSztZQUNwQyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLFNBQVMsS0FBSyxFQUFFOzs7O2dCQUk3QyxLQUFLLENBQUMsV0FBVyxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQzthQUNwQyxDQUFDLENBQUM7U0FDTixDQUFDLENBQUM7S0FDTjs7Ozs7Ozs7O0lBU0QsV0FBVyxDQUFDLFlBQVksRUFBRSxXQUFXLEVBQUU7OztRQUduQyxNQUFNLGlCQUFpQixHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQzs7O1FBRzlELElBQUksWUFBWSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsaUJBQWlCLENBQUMsSUFBSSxJQUFJLENBQUMsUUFBUSxLQUFLLEtBQUssRUFBRTtZQUMvRSxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQzs7O1lBR3JCLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLENBQUM7Ozs7WUFJM0IsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1NBQ3JCO0tBQ0o7Ozs7Ozs7OztJQVNELFFBQVEsQ0FBQyxjQUFjLEVBQUU7UUFDckIsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDOzs7OztRQUsvQixJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxrQkFBa0IsRUFBRTtZQUNuQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsS0FBSyxFQUFFLEtBQUssS0FBSztnQkFDNUIsSUFBSSxLQUFLLElBQUksY0FBYyxFQUFFO29CQUN6QixLQUFLLENBQUMsS0FBSyxHQUFHLFFBQVEsQ0FBQztpQkFDMUI7YUFDSixDQUFDLENBQUM7U0FDTjs7OztRQUlELE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxLQUFLO1lBQzVCLElBQUksS0FBSyxJQUFJLGNBQWMsRUFBRTtnQkFDekIsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQy9DLFFBQVEsS0FBSyxDQUFDLEtBQUssR0FBRyxRQUFRLEVBQUU7YUFDbkM7U0FDSixDQUFDLENBQUM7S0FDTjs7Ozs7Ozs7SUFRRCxVQUFVLEdBQUc7UUFDVCxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7OztRQUcvQixJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEtBQUssRUFBRSxLQUFLLEtBQUs7WUFDbEMsR0FBRyxLQUFLLENBQUMsS0FBSyxLQUFLLE1BQU0sRUFBRTtnQkFDdkIsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQzs7Z0JBRWpDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDcEI7U0FDSixDQUFDLENBQUM7OztRQUdILElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsS0FBSyxFQUFFLEtBQUssS0FBSztZQUNsQyxHQUFHLEtBQUssQ0FBQyxLQUFLLEtBQUssUUFBUSxFQUFFO2dCQUN6QixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDOztnQkFFbkMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUNyQjtTQUNKLENBQUMsQ0FBQztLQUNOOzs7Ozs7Ozs7SUFTRCxJQUFJLENBQUMsV0FBVyxFQUFFO1FBQ2QsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEVBQUUsV0FBVyxDQUFDLENBQUM7S0FDekM7Ozs7Ozs7OztJQVNELEtBQUssQ0FBQyxXQUFXLEVBQUU7UUFDZixJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFBRSxXQUFXLENBQUMsQ0FBQztLQUMzQzs7Ozs7Ozs7SUFRRCxPQUFPLEdBQUc7UUFDTixJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxNQUFNLElBQUk7WUFDNUIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7U0FDcEMsQ0FBQyxDQUFDO0tBQ047Ozs7Ozs7O0lBUUQsUUFBUSxHQUFHO1FBQ1AsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsTUFBTSxJQUFJO1lBQzVCLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1NBQ3RDLENBQUMsQ0FBQztLQUNOOzs7Ozs7Ozs7O0lBVUQsV0FBVyxDQUFDLGVBQWUsRUFBRSxXQUFXLEVBQUU7UUFDdEMsR0FBRyxlQUFlLEtBQUssU0FBUyxJQUFJLFdBQVcsS0FBSyxTQUFTLEVBQUU7WUFDM0QsR0FBRyxlQUFlLEtBQUssUUFBUSxFQUFFOztnQkFFN0IsTUFBTSxNQUFNLFVBQVUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQztnQkFDaEQsTUFBTSxZQUFZLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQzs7O2dCQUcvQyxZQUFZLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDOzs7Z0JBR3JELE1BQU0sQ0FBQyxZQUFZLENBQUMsZUFBZSxFQUFFLEtBQUssQ0FBQyxDQUFDO2dCQUM1QyxNQUFNLENBQUMsWUFBWSxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLGVBQWUsQ0FBQyxDQUFDOzs7Z0JBR2pFLFlBQVksQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLElBQUksQ0FBQyxRQUFRLEdBQUcsS0FBSyxFQUFFLENBQUM7YUFDakUsTUFBTSxHQUFHLGVBQWUsS0FBSyxNQUFNLEVBQUU7O2dCQUVsQyxNQUFNLE1BQU0sUUFBUSxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO2dCQUM5QyxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDOzs7Z0JBRzdDLFdBQVcsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLENBQUM7OztnQkFHdkQsTUFBTSxDQUFDLFlBQVksQ0FBQyxlQUFlLEVBQUUsSUFBSSxDQUFDLENBQUM7Z0JBQzNDLE1BQU0sQ0FBQyxZQUFZLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsQ0FBQzs7O2dCQUdsRSxXQUFXLENBQUMsa0JBQWtCLENBQUMsTUFBTSxJQUFJLENBQUMsUUFBUSxHQUFHLEtBQUssRUFBRSxDQUFDO2FBQ2hFO1NBQ0o7S0FDSjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBcUJELFFBQVEsQ0FBQyxTQUFTLEdBQUcsRUFBRSxFQUFFO1FBQ3JCLEdBQUcsU0FBUyxDQUFDLE1BQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxFQUFFO1lBQzdDLElBQUksTUFBTSxHQUFHLFNBQVMsQ0FBQyxHQUFHLEVBQUUsTUFBTSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQzs7WUFFNUQsT0FBTyxNQUFNLENBQUM7U0FDakIsTUFBTTtZQUNILE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztTQUN0QjtLQUNKOzs7Ozs7Ozs7SUFTRCxXQUFXLENBQUMsWUFBWSxFQUFFO1FBQ3RCLEdBQUcsWUFBWSxLQUFLLFNBQVMsRUFBRTtZQUMzQixPQUFPLENBQUMsWUFBWSxLQUFLLFFBQVEsSUFBSSxNQUFNLEdBQUcsUUFBUSxDQUFDO1NBQzFEO0tBQ0o7Ozs7Ozs7Ozs7SUFVRCxrQkFBa0IsQ0FBQyxhQUFhLEdBQUcsRUFBRSxFQUFFO1FBQ25DLElBQUksYUFBYSxDQUFDLE1BQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxFQUFFO1lBQ3RELElBQUksT0FBTyxHQUFHLGFBQWEsQ0FBQyxNQUFNLENBQUMsTUFBTSxJQUFJLE1BQU0sSUFBSSxTQUFTLENBQUMsQ0FBQzs7WUFFbEUsYUFBYSxDQUFDLE9BQU8sQ0FBQyxNQUFNLElBQUk7Z0JBQzVCLFFBQVEsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFLLEdBQUcsTUFBTSxFQUFFO2FBQy9DLENBQUMsQ0FBQztTQUNOO0tBQ0o7Ozs7Ozs7O0lBUUQsZUFBZSxHQUFHOztRQUVkLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssSUFBSTtZQUN6QixNQUFNLFVBQVUsR0FBRyxLQUFLLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsZUFBZSxDQUFDLENBQUM7O1lBRXRFLElBQUksWUFBWSxHQUFHLFVBQVUsQ0FBQyxZQUFZLENBQUM7O1lBRTNDLE9BQU8sS0FBSyxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsQ0FBQyxFQUFFLFlBQVksQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUN0RCxDQUFDLENBQUM7S0FDTjs7O0lBR0QsYUFBYSxHQUFHO1FBQ1osSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxNQUFNLEVBQUUsS0FBSyxLQUFLO1lBQ3JDLE1BQU0sQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLENBQUMsd0JBQXdCLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDM0UsTUFBTSxDQUFDLFlBQVksQ0FBQyxlQUFlLEVBQUUsQ0FBQyx1QkFBdUIsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNyRixNQUFNLENBQUMsWUFBWSxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1NBQ3BFLENBQUMsQ0FBQztLQUNOOzs7O0lBSUQsWUFBWSxHQUFHO1FBQ1gsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxLQUFLO1lBQ25DLEtBQUssQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLENBQUMsdUJBQXVCLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDekUsS0FBSyxDQUFDLFlBQVksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLHdCQUF3QixFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3pGLENBQUMsQ0FBQztLQUNOOzs7SUFHRCxnQkFBZ0IsR0FBRzs7UUFFZixJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7OztRQUdyQixJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7OztRQUdwQixJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztLQUMzQjtDQUNKOzs7Ozs7OzsifQ==
